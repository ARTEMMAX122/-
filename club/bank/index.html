<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üéÑ –ù–æ–≤–æ–≥–æ–¥–Ω—è—è –í–∞–ª—é—Ç–∞</title>
  <style>
    :root {
      --bg: #0a2e47;
      --snow: #f8fbff;
      --gold: #ffd700;
      --green: #2e8b57;
      --border: #4a6b85;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--snow);
      padding: 16px;
      line-height: 1.6;
      overflow-x: hidden;
      overflow-y: scroll; /* ‚Üê —Ñ–∏–∫—Å –¥—ë—Ä–≥–∞–Ω—å—è —Å–∫—Ä–æ–ª–ª–∞ */
      position: relative;
      min-height: 100vh;
    }

    /* –°–Ω–µ–∂–∏–Ω–∫–∏ */
    #snow-container {
      pointer-events: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    .snowflake {
      position: absolute;
      top: -20px;
      color: white;
      font-size: 1.2rem;
      user-select: none;
      opacity: 0.7;
      animation: fall linear infinite; /* ‚Üê –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ! */
    }
    @keyframes fall {
      to {
        transform: translateY(100vh) rotate(360deg);
      }
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      position: relative;
      z-index: 10;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 2px solid var(--gold);
      margin-bottom: 20px;
    }

    h1 {
      font-size: 2.2rem;
      color: var(--gold);
      text-shadow: 0 0 8px rgba(255,215,0,0.4);
    }

    .top-bar { display: flex; gap: 12px; }
    .btn {
      background: var(--green);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      transition: 0.2s;
    }
    .btn:hover { background: #226b47; }

    .status {
      padding: 12px;
      margin-bottom: 16px;
      border-radius: 6px;
      background: rgba(0,0,0,0.3);
    }
    .status.error { background: rgba(211, 47, 47, 0.2); color: #ffcdd2; }
    .status.success { background: rgba(46, 139, 87, 0.2); }

    table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(20, 45, 65, 0.7);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    th, td {
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th {
      background: var(--green);
      color: white;
      position: sticky;
      top: 0;
    }

    footer {
      margin-top: 30px;
      text-align: center;
      font-size: 0.9rem;
      color: #aaa;
    }
  </style>
</head>
<body>
  <div id="snow-container"></div>

  <div class="container">
    <header>
      <h1>üéÑ –ù–æ–≤–æ–≥–æ–¥–Ω—è—è –í–∞–ª—é—Ç–∞</h1>
      <div class="top-bar">
        <a href="https://lichess.org/team/v1TwDg2i" class="btn" target="_blank">–ö–ª—É–±</a>
        <a href="https://artemmax122.github.io/-/club/bank/what-to-get-coins" class="btn" target="_blank">–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –≤–∞–ª—é—Ç—É</a>
      </div>
    </header>

    <div id="status" class="status">‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö‚Ä¶</div>

    <div style="overflow-x: auto;">
      <table id="dataTable">
        <thead><tr><th>–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>

    <footer>
      üéÖ –û–±–Ω–æ–≤–∏—Ç–µ data.txt –∏ priority.txt –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã
    </footer>
  </div>

  <script>
    // === –ì–ª–æ–±–∞–ª—ã ===
    const statusEl = document.getElementById('status');
    const table = document.getElementById('dataTable');
    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody');

    let headers = [];
    let dataRows = [];
    let priorityColumn = 0;

    // === –£—Ç–∏–ª–∏—Ç—ã ===
    async function fetchText(file) {
      const res = await fetch(file + '?_=' + Date.now());
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.text();
    }

    function computeExpr(str) {
      if (typeof str !== 'string') return str;
      str = str.trim();
      if (/^\d+(\+\d+)*$/.test(str)) {
        const parts = str.split('+').map(s => parseInt(s, 10));
        if (parts.every(n => !isNaN(n))) {
          return parts.reduce((a, b) => a + b, 0);
        }
      }
      return NaN;
    }

    function parseData(text) {
      return text
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'))
        .map(line => {
          const raw = line.split('|').map(s => s.trim());
          const computed = raw.map(cell => {
            const num = computeExpr(cell);
            return isNaN(num) ? cell : num;
          });
          return { raw, computed };
        });
    }

    function detectNumericColumn(colIndex, rows) {
      for (let row of rows) {
        if (row.computed.length <= colIndex) return false;
        const val = row.computed[colIndex];
        if (typeof val !== 'number') return false;
      }
      return true;
    }

    function sortRows(rows, colIndex, isNumeric) {
      return [...rows].sort((a, b) => {
        const A = a.computed[colIndex];
        const B = b.computed[colIndex];
        if (isNumeric) return Number(B) - Number(A);
        const strA = (typeof A === 'string' ? A : String(A)).toLowerCase();
        const strB = (typeof B === 'string' ? B : String(B)).toLowerCase();
        return strB.localeCompare(strA, 'ru', { numeric: true });
      });
    }

    // === –†–µ–Ω–¥–µ—Ä ===
    function renderTable() {
      thead.innerHTML = '';
      const headerRow = document.createElement('tr');
      headers.forEach((h, i) => {
        const th = document.createElement('th');
        th.textContent = h;
        if (i === priorityColumn) th.style.background = '#ff6f00';
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      tbody.innerHTML = '';
      dataRows.forEach(row => {
        const tr = document.createElement('tr');
        row.raw.forEach(cell => {
          const td = document.createElement('td');
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
    }

    function showStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.className = 'status ' + (isError ? 'error' : 'success');
    }

    // === –°–Ω–µ–∂–∏–Ω–∫–∏ (–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–µ) ===
    function createSnowflakes() {
      const container = document.getElementById('snow-container');
      container.innerHTML = '';
      const flakes = '‚ùÖ‚ùÜ‚ùÑ‚úª‚úº‚ùá';
      const count = Math.min(70, Math.floor(window.innerWidth / 12));

      for (let i = 0; i < count; i++) {
        const snow = document.createElement('div');
        snow.className = 'snowflake';
        snow.textContent = flakes[Math.floor(Math.random() * flakes.length)];
        snow.style.left = Math.random() * 100 + 'vw';
        snow.style.opacity = 0.3 + Math.random() * 0.6;
        snow.style.fontSize = (0.6 + Math.random() * 1) + 'rem';
        snow.style.animationDuration = (6 + Math.random() * 10) + 's';
        snow.style.animationDelay = Math.random() * 5 + 's';
        container.appendChild(snow);
      }
    }

    // === –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö ===
    async function loadData() {
      try {
        showStatus('üì• –ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶', false);
        const [dataTxt, priorityTxt] = await Promise.all([
          fetchText('data.txt'),
          fetchText('priority.txt')
        ]);

        const rawRows = parseData(dataTxt);
        const priorityLines = priorityTxt.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));

        if (priorityLines.length < 1) throw new Error('–§–∞–π–ª priority.txt –ø—É—Å—Ç');

        headers = priorityLines[0].split('|').map(s => s.trim()).filter(Boolean);

        // priority for
        priorityColumn = headers.length - 1;
        for (let line of priorityLines.slice(1)) {
          const m = line.match(/priority\s+for\s+["'](.+?)["']/i);
          if (m) {
            const idx = headers.indexOf(m[1].trim());
            if (idx !== -1) priorityColumn = idx;
            break;
          }
        }

        const isNumeric = detectNumericColumn(priorityColumn, rawRows);
        dataRows = sortRows(rawRows, priorityColumn, isNumeric);

        renderTable();
        showStatus(`‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${dataRows.length} —Å—Ç—Ä–æ–∫. –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: "${headers[priorityColumn]}"`, false);

      } catch (err) {
        console.error(err);
        showStatus(`‚ùå ${err.message}`, true);
      }
    }

    // === –°—Ç–∞—Ä—Ç ===
    document.addEventListener('DOMContentLoaded', () => {
      createSnowflakes();
      window.addEventListener('resize', createSnowflakes);
      loadData();
    });
  </script>
</body>
</html>
